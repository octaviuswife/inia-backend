<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PasswordServiceTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">java in Proyecto-Final-UTEC Coverage Results</a> &gt; <a href="index.source.html" class="el_package">utec.proyectofinal.Proyecto.Final.UTEC.services</a> &gt; <span class="el_source">PasswordServiceTest.java</span></div><h1>PasswordServiceTest.java</h1><pre class="source lang-java linenums">package utec.proyectofinal.Proyecto.Final.UTEC.services;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Tests unitarios para PasswordService
 * 
 * Funcionalidades testeadas:
 * - Encriptación de contraseñas con BCrypt
 * - Verificación de contraseñas
 * - Seguridad del hashing (diferentes hashes para misma contraseña)
 * - Manejo de casos edge (null, vacío, espacios)
 */
@ExtendWith(MockitoExtension.class)
@DisplayName(&quot;Tests de PasswordService (Seguridad)&quot;)
<span class="fc" id="L22">class PasswordServiceTest {</span>

    private PasswordService passwordService;

    @BeforeEach
    void setUp() {
<span class="fc" id="L28">        passwordService = new PasswordService();</span>
<span class="fc" id="L29">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña - debe retornar hash BCrypt válido&quot;)
    void encryptPassword_debeRetornarHashBCrypt() {
        // ARRANGE
<span class="fc" id="L35">        String plainPassword = &quot;MiContraseña123!&quot;;</span>

        // ACT
<span class="fc" id="L38">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        // ASSERT
<span class="fc" id="L41">        assertNotNull(encryptedPassword, &quot;El hash no debe ser nulo&quot;);</span>
<span class="fc" id="L42">        assertNotEquals(plainPassword, encryptedPassword, &quot;El hash debe ser diferente a la contraseña original&quot;);</span>
<span class="pc bpc" id="L43" title="3 of 4 branches missed.">        assertTrue(encryptedPassword.startsWith(&quot;$2a$&quot;) || encryptedPassword.startsWith(&quot;$2b$&quot;), </span>
            &quot;Debe ser un hash BCrypt válido&quot;);
<span class="pc bpc" id="L45" title="1 of 2 branches missed.">        assertTrue(encryptedPassword.length() &gt; 50, &quot;El hash BCrypt debe tener longitud apropiada&quot;);</span>
<span class="fc" id="L46">    }</span>

    @Test
    @DisplayName(&quot;Encriptar misma contraseña dos veces - debe generar hashes diferentes&quot;)
    void encryptPassword_mismaContraseña_debeGenerarHashesDiferentes() {
        // ARRANGE
<span class="fc" id="L52">        String plainPassword = &quot;Password123!&quot;;</span>

        // ACT
<span class="fc" id="L55">        String hash1 = passwordService.encryptPassword(plainPassword);</span>
<span class="fc" id="L56">        String hash2 = passwordService.encryptPassword(plainPassword);</span>

        // ASSERT
<span class="fc" id="L59">        assertNotEquals(hash1, hash2, </span>
            &quot;BCrypt debe generar hashes diferentes para la misma contraseña (salt aleatorio)&quot;);
<span class="fc" id="L61">    }</span>

    @Test
    @DisplayName(&quot;Verificar contraseña correcta - debe retornar true&quot;)
    void matchPassword_contraseñaCorrecta_debeRetornarTrue() {
        // ARRANGE
<span class="fc" id="L67">        String plainPassword = &quot;SecurePass456!&quot;;</span>
<span class="fc" id="L68">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        // ACT
<span class="fc" id="L71">        boolean matches = passwordService.matchPassword(plainPassword, encryptedPassword);</span>

        // ASSERT
<span class="fc" id="L74">        assertTrue(matches, &quot;La contraseña correcta debe ser verificada exitosamente&quot;);</span>
<span class="fc" id="L75">    }</span>

    @Test
    @DisplayName(&quot;Verificar contraseña incorrecta - debe retornar false&quot;)
    void matchPassword_contraseñaIncorrecta_debeRetornarFalse() {
        // ARRANGE
<span class="fc" id="L81">        String plainPassword = &quot;CorrectPassword123!&quot;;</span>
<span class="fc" id="L82">        String wrongPassword = &quot;WrongPassword456!&quot;;</span>
<span class="fc" id="L83">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        // ACT
<span class="fc" id="L86">        boolean matches = passwordService.matchPassword(wrongPassword, encryptedPassword);</span>

        // ASSERT
<span class="fc" id="L89">        assertFalse(matches, &quot;Una contraseña incorrecta debe fallar la verificación&quot;);</span>
<span class="fc" id="L90">    }</span>

    @Test
    @DisplayName(&quot;Verificar contraseña con mayúsculas/minúsculas - debe ser case sensitive&quot;)
    void matchPassword_caseSensitive_debeFallar() {
        // ARRANGE
<span class="fc" id="L96">        String plainPassword = &quot;Password123&quot;;</span>
<span class="fc" id="L97">        String wrongCasePassword = &quot;password123&quot;;</span>
<span class="fc" id="L98">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        // ACT
<span class="fc" id="L101">        boolean matches = passwordService.matchPassword(wrongCasePassword, encryptedPassword);</span>

        // ASSERT
<span class="fc" id="L104">        assertFalse(matches, &quot;La verificación debe ser case-sensitive&quot;);</span>
<span class="fc" id="L105">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña con caracteres especiales - debe funcionar correctamente&quot;)
    void encryptPassword_conCaracteresEspeciales_debeFuncionar() {
        // ARRANGE
<span class="fc" id="L111">        String specialPassword = &quot;P@ssw0rd!#$%&amp;*()&quot;;</span>

        // ACT
<span class="fc" id="L114">        String encrypted = passwordService.encryptPassword(specialPassword);</span>
<span class="fc" id="L115">        boolean matches = passwordService.matchPassword(specialPassword, encrypted);</span>

        // ASSERT
<span class="fc" id="L118">        assertNotNull(encrypted);</span>
<span class="fc" id="L119">        assertTrue(matches, &quot;Debe manejar caracteres especiales correctamente&quot;);</span>
<span class="fc" id="L120">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña con espacios - debe preservar espacios&quot;)
    void encryptPassword_conEspacios_debePreservarEspacios() {
        // ARRANGE
<span class="fc" id="L126">        String passwordWithSpaces = &quot;My Pass Word 123&quot;;</span>

        // ACT
<span class="fc" id="L129">        String encrypted = passwordService.encryptPassword(passwordWithSpaces);</span>
<span class="fc" id="L130">        boolean matchesWithSpaces = passwordService.matchPassword(passwordWithSpaces, encrypted);</span>
<span class="fc" id="L131">        boolean matchesWithoutSpaces = passwordService.matchPassword(&quot;MyPassWord123&quot;, encrypted);</span>

        // ASSERT
<span class="fc" id="L134">        assertTrue(matchesWithSpaces, &quot;Debe preservar espacios en la contraseña&quot;);</span>
<span class="fc" id="L135">        assertFalse(matchesWithoutSpaces, &quot;No debe coincidir sin los espacios&quot;);</span>
<span class="fc" id="L136">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña muy larga - debe funcionar&quot;)
    void encryptPassword_contraseñaMuyLarga_debeFuncionar() {
        // ARRANGE
        // BCrypt tiene un límite de 72 bytes, así que probamos con 70 caracteres
<span class="fc" id="L143">        String longPassword = &quot;A&quot;.repeat(70);</span>

        // ACT
<span class="fc" id="L146">        String encrypted = passwordService.encryptPassword(longPassword);</span>
<span class="fc" id="L147">        boolean matches = passwordService.matchPassword(longPassword, encrypted);</span>

        // ASSERT
<span class="fc" id="L150">        assertNotNull(encrypted);</span>
<span class="fc" id="L151">        assertTrue(matches, &quot;Debe manejar contraseñas largas (hasta 72 bytes)&quot;);</span>
<span class="fc" id="L152">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña muy corta - debe funcionar&quot;)
    void encryptPassword_contraseñaMuyCorta_debeFuncionar() {
        // ARRANGE
<span class="fc" id="L158">        String shortPassword = &quot;Ab1&quot;;</span>

        // ACT
<span class="fc" id="L161">        String encrypted = passwordService.encryptPassword(shortPassword);</span>
<span class="fc" id="L162">        boolean matches = passwordService.matchPassword(shortPassword, encrypted);</span>

        // ASSERT
<span class="fc" id="L165">        assertNotNull(encrypted);</span>
<span class="fc" id="L166">        assertTrue(matches, &quot;Debe manejar contraseñas cortas&quot;);</span>
<span class="fc" id="L167">    }</span>

    @Test
    @DisplayName(&quot;Verificar con contraseña vacía - debe retornar false&quot;)
    void matchPassword_contraseñaVacia_debeRetornarFalse() {
        // ARRANGE
<span class="fc" id="L173">        String plainPassword = &quot;ValidPassword123&quot;;</span>
<span class="fc" id="L174">        String encryptedPassword = passwordService.encryptPassword(plainPassword);</span>

        // ACT
<span class="fc" id="L177">        boolean matches = passwordService.matchPassword(&quot;&quot;, encryptedPassword);</span>

        // ASSERT
<span class="fc" id="L180">        assertFalse(matches, &quot;Una contraseña vacía no debe coincidir&quot;);</span>
<span class="fc" id="L181">    }</span>

    @Test
    @DisplayName(&quot;Encriptar contraseña con Unicode - debe funcionar&quot;)
    void encryptPassword_conUnicode_debeFuncionar() {
        // ARRANGE
<span class="fc" id="L187">        String unicodePassword = &quot;Contraseña123áéíóú&quot;;</span>

        // ACT
<span class="fc" id="L190">        String encrypted = passwordService.encryptPassword(unicodePassword);</span>
<span class="fc" id="L191">        boolean matches = passwordService.matchPassword(unicodePassword, encrypted);</span>

        // ASSERT
<span class="fc" id="L194">        assertNotNull(encrypted);</span>
<span class="fc" id="L195">        assertTrue(matches, &quot;Debe manejar caracteres Unicode correctamente&quot;);</span>
<span class="fc" id="L196">    }</span>

    @Test
    @DisplayName(&quot;Verificar múltiples contraseñas diferentes - solo una debe coincidir&quot;)
    void matchPassword_multiplesCandidatos_soloUnaCoincide() {
        // ARRANGE
<span class="fc" id="L202">        String correctPassword = &quot;CorrectOne123!&quot;;</span>
<span class="fc" id="L203">        String encryptedPassword = passwordService.encryptPassword(correctPassword);</span>
        
<span class="fc" id="L205">        String[] wrongPasswords = {</span>
            &quot;WrongOne123!&quot;,
            &quot;CorrectOne124!&quot;,
            &quot;correctone123!&quot;,
            &quot;CorrectOne123&quot;,
            &quot;CorrectOne123!!&quot;
        };

        // ACT &amp; ASSERT
<span class="fc" id="L214">        assertTrue(passwordService.matchPassword(correctPassword, encryptedPassword), </span>
            &quot;La contraseña correcta debe coincidir&quot;);
        
<span class="fc bfc" id="L217" title="All 2 branches covered.">        for (String wrongPassword : wrongPasswords) {</span>
<span class="fc" id="L218">            assertFalse(passwordService.matchPassword(wrongPassword, encryptedPassword), </span>
                &quot;La contraseña '&quot; + wrongPassword + &quot;' no debe coincidir&quot;);
        }
<span class="fc" id="L221">    }</span>

    @Test
    @DisplayName(&quot;Encriptar y verificar contraseña compleja - debe funcionar&quot;)
    void encryptPassword_contraseñaCompleja_debeFuncionar() {
        // ARRANGE
<span class="fc" id="L227">        String complexPassword = &quot;C0mpl3x!P@ssw0rd#2024$%&amp;&quot;;</span>

        // ACT
<span class="fc" id="L230">        String encrypted = passwordService.encryptPassword(complexPassword);</span>
<span class="fc" id="L231">        boolean matches = passwordService.matchPassword(complexPassword, encrypted);</span>

        // ASSERT
<span class="fc" id="L234">        assertNotNull(encrypted);</span>
<span class="fc" id="L235">        assertTrue(matches, &quot;Debe manejar contraseñas complejas correctamente&quot;);</span>
<span class="fc" id="L236">    }</span>

    @Test
    @DisplayName(&quot;Encriptar misma contraseña 10 veces - todos los hashes deben ser únicos&quot;)
    void encryptPassword_10Veces_todosHashesUnicos() {
        // ARRANGE
<span class="fc" id="L242">        String password = &quot;TestPassword123&quot;;</span>
<span class="fc" id="L243">        int iterations = 10;</span>

        // ACT
<span class="fc" id="L246">        String[] hashes = new String[iterations];</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (int i = 0; i &lt; iterations; i++) {</span>
<span class="fc" id="L248">            hashes[i] = passwordService.encryptPassword(password);</span>
        }

        // ASSERT
<span class="fc bfc" id="L252" title="All 2 branches covered.">        for (int i = 0; i &lt; iterations; i++) {</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">            for (int j = i + 1; j &lt; iterations; j++) {</span>
<span class="fc" id="L254">                assertNotEquals(hashes[i], hashes[j], </span>
                    &quot;Todos los hashes deben ser únicos debido al salt aleatorio&quot;);
            }
        }

        // Verificar que todos los hashes funcionan
<span class="fc bfc" id="L260" title="All 2 branches covered.">        for (String hash : hashes) {</span>
<span class="fc" id="L261">            assertTrue(passwordService.matchPassword(password, hash), </span>
                &quot;Todos los hashes deben verificar correctamente&quot;);
        }
<span class="fc" id="L264">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>